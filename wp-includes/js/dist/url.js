/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9681:
/***/ ((module) => {

var characterMap = {
	"ГЂ": "A",
	"ГЃ": "A",
	"Г‚": "A",
	"Гѓ": "A",
	"Г„": "A",
	"Г…": "A",
	"бє¤": "A",
	"бє®": "A",
	"бєІ": "A",
	"бєґ": "A",
	"бє¶": "A",
	"Г†": "AE",
	"бє¦": "A",
	"бє°": "A",
	"И‚": "A",
	"бєў": "A",
	"бє ": "A",
	"бєЁ": "A",
	"бєЄ": "A",
	"бє¬": "A",
	"Г‡": "C",
	"бё€": "C",
	"Г€": "E",
	"Г‰": "E",
	"ГЉ": "E",
	"Г‹": "E",
	"бєѕ": "E",
	"бё–": "E",
	"б»Ђ": "E",
	"бё”": "E",
	"бёњ": "E",
	"И†": "E",
	"бєє": "E",
	"бєј": "E",
	"бєё": "E",
	"б»‚": "E",
	"б»„": "E",
	"б»†": "E",
	"ГЊ": "I",
	"ГЌ": "I",
	"ГЋ": "I",
	"ГЏ": "I",
	"бё®": "I",
	"ИЉ": "I",
	"б»€": "I",
	"б»Љ": "I",
	"Гђ": "D",
	"Г‘": "N",
	"Г’": "O",
	"Г“": "O",
	"Г”": "O",
	"Г•": "O",
	"Г–": "O",
	"Г": "O",
	"б»ђ": "O",
	"б№Њ": "O",
	"б№’": "O",
	"ИЋ": "O",
	"б»Ћ": "O",
	"б»Њ": "O",
	"б»”": "O",
	"б»–": "O",
	"б»": "O",
	"б»њ": "O",
	"б»ћ": "O",
	"б» ": "O",
	"б»љ": "O",
	"б»ў": "O",
	"Г™": "U",
	"Гљ": "U",
	"Г›": "U",
	"Гњ": "U",
	"б»¦": "U",
	"б»¤": "U",
	"б»¬": "U",
	"б»®": "U",
	"б»°": "U",
	"Гќ": "Y",
	"Г ": "a",
	"ГЎ": "a",
	"Гў": "a",
	"ГЈ": "a",
	"Г¤": "a",
	"ГҐ": "a",
	"бєҐ": "a",
	"бєЇ": "a",
	"бєі": "a",
	"бєµ": "a",
	"бє·": "a",
	"Г¦": "ae",
	"бє§": "a",
	"бє±": "a",
	"Иѓ": "a",
	"бєЈ": "a",
	"бєЎ": "a",
	"бє©": "a",
	"бє«": "a",
	"бє­": "a",
	"Г§": "c",
	"бё‰": "c",
	"ГЁ": "e",
	"Г©": "e",
	"ГЄ": "e",
	"Г«": "e",
	"бєї": "e",
	"бё—": "e",
	"б»Ѓ": "e",
	"бё•": "e",
	"бёќ": "e",
	"И‡": "e",
	"бє»": "e",
	"бєЅ": "e",
	"бє№": "e",
	"б»ѓ": "e",
	"б»…": "e",
	"б»‡": "e",
	"Г¬": "i",
	"Г­": "i",
	"Г®": "i",
	"ГЇ": "i",
	"бёЇ": "i",
	"И‹": "i",
	"б»‰": "i",
	"б»‹": "i",
	"Г°": "d",
	"Г±": "n",
	"ГІ": "o",
	"Гі": "o",
	"Гґ": "o",
	"Гµ": "o",
	"Г¶": "o",
	"Гё": "o",
	"б»‘": "o",
	"б№Ќ": "o",
	"б№“": "o",
	"ИЏ": "o",
	"б»Џ": "o",
	"б»Ќ": "o",
	"б»•": "o",
	"б»—": "o",
	"б»™": "o",
	"б»ќ": "o",
	"б»џ": "o",
	"б»Ў": "o",
	"б»›": "o",
	"б»Ј": "o",
	"Г№": "u",
	"Гє": "u",
	"Г»": "u",
	"Гј": "u",
	"б»§": "u",
	"б»Ґ": "u",
	"б»­": "u",
	"б»Ї": "u",
	"б»±": "u",
	"ГЅ": "y",
	"Гї": "y",
	"ДЂ": "A",
	"ДЃ": "a",
	"Д‚": "A",
	"Дѓ": "a",
	"Д„": "A",
	"Д…": "a",
	"Д†": "C",
	"Д‡": "c",
	"Д€": "C",
	"Д‰": "c",
	"ДЉ": "C",
	"Д‹": "c",
	"ДЊ": "C",
	"ДЌ": "c",
	"CМ†": "C",
	"cМ†": "c",
	"ДЋ": "D",
	"ДЏ": "d",
	"Дђ": "D",
	"Д‘": "d",
	"Д’": "E",
	"Д“": "e",
	"Д”": "E",
	"Д•": "e",
	"Д–": "E",
	"Д—": "e",
	"Д": "E",
	"Д™": "e",
	"Дљ": "E",
	"Д›": "e",
	"Дњ": "G",
	"Зґ": "G",
	"Дќ": "g",
	"Зµ": "g",
	"Дћ": "G",
	"Дџ": "g",
	"Д ": "G",
	"ДЎ": "g",
	"Дў": "G",
	"ДЈ": "g",
	"Д¤": "H",
	"ДҐ": "h",
	"Д¦": "H",
	"Д§": "h",
	"бёЄ": "H",
	"бё«": "h",
	"ДЁ": "I",
	"Д©": "i",
	"ДЄ": "I",
	"Д«": "i",
	"Д¬": "I",
	"Д­": "i",
	"Д®": "I",
	"ДЇ": "i",
	"Д°": "I",
	"Д±": "i",
	"ДІ": "IJ",
	"Ді": "ij",
	"Дґ": "J",
	"Дµ": "j",
	"Д¶": "K",
	"Д·": "k",
	"бё°": "K",
	"бё±": "k",
	"KМ†": "K",
	"kМ†": "k",
	"Д№": "L",
	"Дє": "l",
	"Д»": "L",
	"Дј": "l",
	"ДЅ": "L",
	"Дѕ": "l",
	"Дї": "L",
	"ЕЂ": "l",
	"ЕЃ": "l",
	"Е‚": "l",
	"бёѕ": "M",
	"бёї": "m",
	"MМ†": "M",
	"mМ†": "m",
	"Еѓ": "N",
	"Е„": "n",
	"Е…": "N",
	"Е†": "n",
	"Е‡": "N",
	"Е€": "n",
	"Е‰": "n",
	"NМ†": "N",
	"nМ†": "n",
	"ЕЊ": "O",
	"ЕЌ": "o",
	"ЕЋ": "O",
	"ЕЏ": "o",
	"Еђ": "O",
	"Е‘": "o",
	"Е’": "OE",
	"Е“": "oe",
	"PМ†": "P",
	"pМ†": "p",
	"Е”": "R",
	"Е•": "r",
	"Е–": "R",
	"Е—": "r",
	"Е": "R",
	"Е™": "r",
	"RМ†": "R",
	"rМ†": "r",
	"И’": "R",
	"И“": "r",
	"Ељ": "S",
	"Е›": "s",
	"Ењ": "S",
	"Еќ": "s",
	"Ећ": "S",
	"И": "S",
	"И™": "s",
	"Еџ": "s",
	"Е ": "S",
	"ЕЎ": "s",
	"Еў": "T",
	"ЕЈ": "t",
	"И›": "t",
	"Иљ": "T",
	"Е¤": "T",
	"ЕҐ": "t",
	"Е¦": "T",
	"Е§": "t",
	"TМ†": "T",
	"tМ†": "t",
	"ЕЁ": "U",
	"Е©": "u",
	"ЕЄ": "U",
	"Е«": "u",
	"Е¬": "U",
	"Е­": "u",
	"Е®": "U",
	"ЕЇ": "u",
	"Е°": "U",
	"Е±": "u",
	"ЕІ": "U",
	"Еі": "u",
	"И–": "U",
	"И—": "u",
	"VМ†": "V",
	"vМ†": "v",
	"Еґ": "W",
	"Еµ": "w",
	"бє‚": "W",
	"бєѓ": "w",
	"XМ†": "X",
	"xМ†": "x",
	"Е¶": "Y",
	"Е·": "y",
	"Её": "Y",
	"YМ†": "Y",
	"yМ†": "y",
	"Е№": "Z",
	"Еє": "z",
	"Е»": "Z",
	"Еј": "z",
	"ЕЅ": "Z",
	"Еѕ": "z",
	"Еї": "s",
	"Ж’": "f",
	"Ж ": "O",
	"ЖЎ": "o",
	"ЖЇ": "U",
	"Ж°": "u",
	"ЗЌ": "A",
	"ЗЋ": "a",
	"ЗЏ": "I",
	"Зђ": "i",
	"З‘": "O",
	"З’": "o",
	"З“": "U",
	"З”": "u",
	"З•": "U",
	"З–": "u",
	"З—": "U",
	"З": "u",
	"З™": "U",
	"Зљ": "u",
	"З›": "U",
	"Зњ": "u",
	"б»Ё": "U",
	"б»©": "u",
	"б№ё": "U",
	"б№№": "u",
	"Зє": "A",
	"З»": "a",
	"Зј": "AE",
	"ЗЅ": "ae",
	"Зѕ": "O",
	"Зї": "o",
	"Гћ": "TH",
	"Гѕ": "th",
	"б№”": "P",
	"б№•": "p",
	"б№¤": "S",
	"б№Ґ": "s",
	"XМЃ": "X",
	"xМЃ": "x",
	"Рѓ": "Р“",
	"С“": "Рі",
	"РЊ": "Рљ",
	"Сњ": "Рє",
	"AМ‹": "A",
	"aМ‹": "a",
	"EМ‹": "E",
	"eМ‹": "e",
	"IМ‹": "I",
	"iМ‹": "i",
	"Зё": "N",
	"З№": "n",
	"б»’": "O",
	"б»“": "o",
	"б№ђ": "O",
	"б№‘": "o",
	"б»Є": "U",
	"б»«": "u",
	"бєЂ": "W",
	"бєЃ": "w",
	"б»І": "Y",
	"б»і": "y",
	"ИЂ": "A",
	"ИЃ": "a",
	"И„": "E",
	"И…": "e",
	"И€": "I",
	"И‰": "i",
	"ИЊ": "O",
	"ИЌ": "o",
	"Иђ": "R",
	"И‘": "r",
	"И”": "U",
	"И•": "u",
	"BМЊ": "B",
	"bМЊ": "b",
	"ДЊМЈ": "C",
	"ДЌМЈ": "c",
	"ГЉМЊ": "E",
	"ГЄМЊ": "e",
	"FМЊ": "F",
	"fМЊ": "f",
	"З¦": "G",
	"З§": "g",
	"Ић": "H",
	"Иџ": "h",
	"JМЊ": "J",
	"З°": "j",
	"ЗЁ": "K",
	"З©": "k",
	"MМЊ": "M",
	"mМЊ": "m",
	"PМЊ": "P",
	"pМЊ": "p",
	"QМЊ": "Q",
	"qМЊ": "q",
	"ЕМ©": "R",
	"Е™М©": "r",
	"б№¦": "S",
	"б№§": "s",
	"VМЊ": "V",
	"vМЊ": "v",
	"WМЊ": "W",
	"wМЊ": "w",
	"XМЊ": "X",
	"xМЊ": "x",
	"YМЊ": "Y",
	"yМЊ": "y",
	"AМ§": "A",
	"aМ§": "a",
	"BМ§": "B",
	"bМ§": "b",
	"бёђ": "D",
	"бё‘": "d",
	"ИЁ": "E",
	"И©": "e",
	"ЖђМ§": "E",
	"Й›М§": "e",
	"бёЁ": "H",
	"бё©": "h",
	"IМ§": "I",
	"iМ§": "i",
	"Ж—М§": "I",
	"ЙЁМ§": "i",
	"MМ§": "M",
	"mМ§": "m",
	"OМ§": "O",
	"oМ§": "o",
	"QМ§": "Q",
	"qМ§": "q",
	"UМ§": "U",
	"uМ§": "u",
	"XМ§": "X",
	"xМ§": "x",
	"ZМ§": "Z",
	"zМ§": "z",
	"Р№":"Рё",
	"Р™":"Р",
	"С‘":"Рµ",
	"РЃ":"Р•",
};

var chars = Object.keys(characterMap).join('|');
var allAccents = new RegExp(chars, 'g');
var firstAccent = new RegExp(chars, '');

function matcher(match) {
	return characterMap[match];
}

var removeAccents = function(string) {
	return string.replace(allAccents, matcher);
};

var hasAccents = function(string) {
	return !!string.match(firstAccent);
};

module.exports = removeAccents;
module.exports.has = hasAccents;
module.exports.remove = removeAccents;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  addQueryArgs: () => (/* reexport */ addQueryArgs),
  buildQueryString: () => (/* reexport */ buildQueryString),
  cleanForSlug: () => (/* reexport */ cleanForSlug),
  filterURLForDisplay: () => (/* reexport */ filterURLForDisplay),
  getAuthority: () => (/* reexport */ getAuthority),
  getFilename: () => (/* reexport */ getFilename),
  getFragment: () => (/* reexport */ getFragment),
  getPath: () => (/* reexport */ getPath),
  getPathAndQueryString: () => (/* reexport */ getPathAndQueryString),
  getProtocol: () => (/* reexport */ getProtocol),
  getQueryArg: () => (/* reexport */ getQueryArg),
  getQueryArgs: () => (/* reexport */ getQueryArgs),
  getQueryString: () => (/* reexport */ getQueryString),
  hasQueryArg: () => (/* reexport */ hasQueryArg),
  isEmail: () => (/* reexport */ isEmail),
  isPhoneNumber: () => (/* reexport */ isPhoneNumber),
  isURL: () => (/* reexport */ isURL),
  isValidAuthority: () => (/* reexport */ isValidAuthority),
  isValidFragment: () => (/* reexport */ isValidFragment),
  isValidPath: () => (/* reexport */ isValidPath),
  isValidProtocol: () => (/* reexport */ isValidProtocol),
  isValidQueryString: () => (/* reexport */ isValidQueryString),
  normalizePath: () => (/* reexport */ normalizePath),
  prependHTTP: () => (/* reexport */ prependHTTP),
  prependHTTPS: () => (/* reexport */ prependHTTPS),
  removeQueryArgs: () => (/* reexport */ removeQueryArgs),
  safeDecodeURI: () => (/* reexport */ safeDecodeURI),
  safeDecodeURIComponent: () => (/* reexport */ safeDecodeURIComponent)
});

;// ./node_modules/@wordpress/url/build-module/is-url.js
/* wp:polyfill */
/**
 * Determines whether the given string looks like a URL.
 *
 * @param {string} url The string to scrutinise.
 *
 * @example
 * ```js
 * const isURL = isURL( 'https://wordpress.org' ); // true
 * ```
 *
 * @see https://url.spec.whatwg.org/
 * @see https://url.spec.whatwg.org/#valid-url-string
 *
 * @return {boolean} Whether or not it looks like a URL.
 */
function isURL(url) {
  // A URL can be considered value if the `URL` constructor is able to parse
  // it. The constructor throws an error for an invalid URL.
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

;// ./node_modules/@wordpress/url/build-module/is-email.js
const EMAIL_REGEXP = /^(mailto:)?[a-z0-9._%+-]+@[a-z0-9][a-z0-9.-]*\.[a-z]{2,63}$/i;

/**
 * Determines whether the given string looks like an email.
 *
 * @param {string} email The string to scrutinise.
 *
 * @example
 * ```js
 * const isEmail = isEmail( 'hello@wordpress.org' ); // true
 * ```
 *
 * @return {boolean} Whether or not it looks like an email.
 */
function isEmail(email) {
  return EMAIL_REGEXP.test(email);
}

;// ./node_modules/@wordpress/url/build-module/is-phone-number.js
const PHONE_REGEXP = /^(tel:)?(\+)?\d{6,15}$/;

/**
 * Determines whether the given string looks like a phone number.
 *
 * @param {string} phoneNumber The string to scrutinize.
 *
 * @example
 * ```js
 * const isPhoneNumber = isPhoneNumber('+1 (555) 123-4567'); // true
 * ```
 *
 * @return {boolean} Whether or not it looks like a phone number.
 */
function isPhoneNumber(phoneNumber) {
  // Remove any separator from phone number.
  phoneNumber = phoneNumber.replace(/[-.() ]/g, '');
  return PHONE_REGEXP.test(phoneNumber);
}

;// ./node_modules/@wordpress/url/build-module/get-protocol.js
/**
 * Returns the protocol part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const protocol1 = getProtocol( 'tel:012345678' ); // 'tel:'
 * const protocol2 = getProtocol( 'https://wordpress.org' ); // 'https:'
 * ```
 *
 * @return {string|void} The protocol part of the URL.
 */
function getProtocol(url) {
  const matches = /^([^\s:]+:)/.exec(url);
  if (matches) {
    return matches[1];
  }
}

;// ./node_modules/@wordpress/url/build-module/is-valid-protocol.js
/**
 * Tests if a url protocol is valid.
 *
 * @param {string} protocol The url protocol.
 *
 * @example
 * ```js
 * const isValid = isValidProtocol( 'https:' ); // true
 * const isNotValid = isValidProtocol( 'https :' ); // false
 * ```
 *
 * @return {boolean} True if the argument is a valid protocol (e.g. http:, tel:).
 */
function isValidProtocol(protocol) {
  if (!protocol) {
    return false;
  }
  return /^[a-z\-.\+]+[0-9]*:$/i.test(protocol);
}

;// ./node_modules/@wordpress/url/build-module/get-authority.js
/**
 * Returns the authority part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const authority1 = getAuthority( 'https://wordpress.org/help/' ); // 'wordpress.org'
 * const authority2 = getAuthority( 'https://localhost:8080/test/' ); // 'localhost:8080'
 * ```
 *
 * @return {string|void} The authority part of the URL.
 */
function getAuthority(url) {
  const matches = /^[^\/\s:]+:(?:\/\/)?\/?([^\/\s#?]+)[\/#?]{0,1}\S*$/.exec(url);
  if (matches) {
    return matches[1];
  }
}

;// ./node_modules/@wordpress/url/build-module/is-valid-authority.js
/**
 * Checks for invalid characters within the provided authority.
 *
 * @param {string} authority A string containing the URL authority.
 *
 * @example
 * ```js
 * const isValid = isValidAuthority( 'wordpress.org' ); // true
 * const isNotValid = isValidAuthority( 'wordpress#org' ); // false
 * ```
 *
 * @return {boolean} True if the argument contains a valid authority.
 */
function isValidAuthority(authority) {
  if (!authority) {
    return false;
  }
  return /^[^\s#?]+$/.test(authority);
}

;// ./node_modules/@wordpress/url/build-module/get-path.js
/**
 * Returns the path part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const path1 = getPath( 'http://localhost:8080/this/is/a/test?query=true' ); // 'this/is/a/test'
 * const path2 = getPath( 'https://wordpress.org/help/faq/' ); // 'help/faq'
 * ```
 *
 * @return {string|void} The path part of the URL.
 */
function getPath(url) {
  const matches = /^[^\/\s:]+:(?:\/\/)?[^\/\s#?]+[\/]([^\s#?]+)[#?]{0,1}\S*$/.exec(url);
  if (matches) {
    return matches[1];
  }
}

;// ./node_modules/@wordpress/url/build-module/is-valid-path.js
/**
 * Checks for invalid characters within the provided path.
 *
 * @param {string} path The URL path.
 *
 * @example
 * ```js
 * const isValid = isValidPath( 'test/path/' ); // true
 * const isNotValid = isValidPath( '/invalid?test/path/' ); // false
 * ```
 *
 * @return {boolean} True if the argument contains a valid path
 */
function isValidPath(path) {
  if (!path) {
    return false;
  }
  return /^[^\s#?]+$/.test(path);
}

;// ./node_modules/@wordpress/url/build-module/get-query-string.js
/* wp:polyfill */
/**
 * Returns the query string part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const queryString = getQueryString( 'http://localhost:8080/this/is/a/test?query=true#fragment' ); // 'query=true'
 * ```
 *
 * @return {string|void} The query string part of the URL.
 */
function getQueryString(url) {
  let query;
  try {
    query = new URL(url, 'http://example.com').search.substring(1);
  } catch (error) {}
  if (query) {
    return query;
  }
}

;// ./node_modules/@wordpress/url/build-module/build-query-string.js
/**
 * Generates URL-encoded query string using input query data.
 *
 * It is intended to behave equivalent as PHP's `http_build_query`, configured
 * with encoding type PHP_QUERY_RFC3986 (spaces as `%20`).
 *
 * @example
 * ```js
 * const queryString = buildQueryString( {
 *    simple: 'is ok',
 *    arrays: [ 'are', 'fine', 'too' ],
 *    objects: {
 *       evenNested: {
 *          ok: 'yes',
 *       },
 *    },
 * } );
 * // "simple=is%20ok&arrays%5B0%5D=are&arrays%5B1%5D=fine&arrays%5B2%5D=too&objects%5BevenNested%5D%5Bok%5D=yes"
 * ```
 *
 * @param {Record<string,*>} data Data to encode.
 *
 * @return {string} Query string.
 */
function buildQueryString(data) {
  let string = '';
  const stack = Object.entries(data);
  let pair;
  while (pair = stack.shift()) {
    let [key, value] = pair;

    // Support building deeply nested data, from array or object values.
    const hasNestedData = Array.isArray(value) || value && value.constructor === Object;
    if (hasNestedData) {
      // Push array or object values onto the stack as composed of their
      // original key and nested index or key, retaining order by a
      // combination of Array#reverse and Array#unshift onto the stack.
      const valuePairs = Object.entries(value).reverse();
      for (const [member, memberValue] of valuePairs) {
        stack.unshift([`${key}[${member}]`, memberValue]);
      }
    } else if (value !== undefined) {
      // Null is treated as special case, equivalent to empty string.
      if (value === null) {
        value = '';
      }
      string += '&' + [key, value].map(encodeURIComponent).join('=');
    }
  }

  // Loop will concatenate with leading `&`, but it's only expected for all
  // but the first query parameter. This strips the leading `&`, while still
  // accounting for the case that the string may in-fact be empty.
  return string.substr(1);
}

;// ./node_modules/@wordpress/url/build-module/is-valid-query-string.js
/**
 * Checks for invalid characters within the provided query string.
 *
 * @param {string} queryString The query string.
 *
 * @example
 * ```js
 * const isValid = isValidQueryString( 'query=true&another=false' ); // true
 * const isNotValid = isValidQueryString( 'query=true?another=false' ); // false
 * ```
 *
 * @return {boolean} True if the argument contains a valid query string.
 */
function isValidQueryString(queryString) {
  if (!queryString) {
    return false;
  }
  return /^[^\s#?\/]+$/.test(queryString);
}

;// ./node_modules/@wordpress/url/build-module/get-path-and-query-string.js
/**
 * Internal dependencies
 */


/**
 * Returns the path part and query string part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const pathAndQueryString1 = getPathAndQueryString( 'http://localhost:8080/this/is/a/test?query=true' ); // '/this/is/a/test?query=true'
 * const pathAndQueryString2 = getPathAndQueryString( 'https://wordpress.org/help/faq/' ); // '/help/faq'
 * ```
 *
 * @return {string} The path part and query string part of the URL.
 */
function getPathAndQueryString(url) {
  const path = getPath(url);
  const queryString = getQueryString(url);
  let value = '/';
  if (path) {
    value += path;
  }
  if (queryString) {
    value += `?${queryString}`;
  }
  return value;
}

;// ./node_modules/@wordpress/url/build-module/get-fragment.js
/**
 * Returns the fragment part of the URL.
 *
 * @param {string} url The full URL
 *
 * @example
 * ```js
 * const fragment1 = getFragment( 'http://localhost:8080/this/is/a/test?query=true#fragment' ); // '#fragment'
 * const fragment2 = getFragment( 'https://wordpress.org#another-fragment?query=true' ); // '#another-fragment'
 * ```
 *
 * @return {string|void} The fragment part of the URL.
 */
function getFragment(url) {
  const matches = /^\S+?(#[^\s\?]*)/.exec(url);
  if (matches) {
    return matches[1];
  }
}

;// ./node_modules/@wordpress/url/build-module/is-valid-fragment.js
/**
 * Checks for invalid characters within the provided fragment.
 *
 * @param {string} fragment The url fragment.
 *
 * @example
 * ```js
 * const isValid = isValidFragment( '#valid-fragment' ); // true
 * const isNotValid = isValidFragment( '#invalid-#fragment' ); // false
 * ```
 *
 * @return {boolean} True if the argument contains a valid fragment.
 */
function isValidFragment(fragment) {
  if (!fragment) {
    return false;
  }
  return /^#[^\s#?\/]*$/.test(fragment);
}

;// ./node_modules/@wordpress/url/build-module/safe-decode-uri-component.js
/**
 * Safely decodes a URI component with `decodeURIComponent`. Returns the URI component unmodified if
 * `decodeURIComponent` throws an error.
 *
 * @param {string} uriComponent URI component to decode.
 *
 * @return {string} Decoded URI component if possible.
 */
function safeDecodeURIComponent(uriComponent) {
  try {
    return decodeURIComponent(uriComponent);
  } catch (uriComponentError) {
    return uriComponent;
  }
}

;// ./node_modules/@wordpress/url/build-module/get-query-args.js
/**
 * Internal dependencies
 */



/** @typedef {import('./get-query-arg').QueryArgParsed} QueryArgParsed */

/**
 * @typedef {Record<string,QueryArgParsed>} QueryArgs
 */

/**
 * Sets a value in object deeply by a given array of path segments. Mutates the
 * object reference.
 *
 * @param {Record<string,*>} object Object in which to assign.
 * @param {string[]}         path   Path segment at which to set value.
 * @param {*}                value  Value to set.
 */
function setPath(object, path, value) {
  const length = path.length;
  const lastIndex = length - 1;
  for (let i = 0; i < length; i++) {
    let key = path[i];
    if (!key && Array.isArray(object)) {
      // If key is empty string and next value is array, derive key from
      // the current length of the array.
      key = object.length.toString();
    }
    key = ['__proto__', 'constructor', 'prototype'].includes(key) ? key.toUpperCase() : key;

    // If the next key in the path is numeric (or empty string), it will be
    // created as an array. Otherwise, it will be created as an object.
    const isNextKeyArrayIndex = !isNaN(Number(path[i + 1]));
    object[key] = i === lastIndex ?
    // If at end of path, assign the intended value.
    value :
    // Otherwise, advance to the next object in the path, creating
    // it if it does not yet exist.
    object[key] || (isNextKeyArrayIndex ? [] : {});
    if (Array.isArray(object[key]) && !isNextKeyArrayIndex) {
      // If we current key is non-numeric, but the next value is an
      // array, coerce the value to an object.
      object[key] = {
        ...object[key]
      };
    }

    // Update working reference object to the next in the path.
    object = object[key];
  }
}

/**
 * Returns an object of query arguments of the given URL. If the given URL is
 * invalid or has no querystring, an empty object is returned.
 *
 * @param {string} url URL.
 *
 * @example
 * ```js
 * const foo = getQueryArgs( 'https://wordpress.org?foo=bar&bar=baz' );
 * // { "foo": "bar", "bar": "baz" }
 * ```
 *
 * @return {QueryArgs} Query args object.
 */
function getQueryArgs(url) {
  return (getQueryString(url) || ''
  // Normalize space encoding, accounting for PHP URL encoding
  // corresponding to `application/x-www-form-urlencoded`.
  //
  // See: https://tools.ietf.org/html/rfc1866#section-8.2.1
  ).replace(/\+/g, '%20').split('&').reduce((accumulator, keyValue) => {
    const [key, value = ''] = keyValue.split('=')
    // Filtering avoids decoding as `undefined` for value, where
    // default is restored in destructuring assignment.
    .filter(Boolean).map(safeDecodeURIComponent);
    if (key) {
      const segments = key.replace(/\]/g, '').split('[');
      setPath(accumulator, segments, value);
    }
    return accumulator;
  }, Object.create(null));
}

;// ./node_modules/@wordpress/url/build-module/add-query-args.js
/**
 * Internal dependencies
 */




/**
 * Appends arguments as querystring to the provided URL. If the URL already
 * includes query arguments, the arguments are merged with (and take precedent
 * over) the existing set.
 *
 * @param {string} [url=''] URL to which arguments should be appended. If omitted,
 *                          only the resulting querystring is returned.
 * @param {Object} [args]   Query arguments to apply to URL.
 *
 * @example
 * ```js
 * const newURL = addQueryArgs( 'https://google.com', { q: 'test' } ); // https://google.com/?q=test
 * ```
 *
 * @return {string} URL with arguments applied.
 */
function addQueryArgs(url = '', args) {
  // If no arguments are to be appended, return original URL.
  if (!args || !Object.keys(args).length) {
    return url;
  }
  const fragment = getFragment(url) || '';
  let baseUrl = url.replace(fragment, '');

  // Determine whether URL already had query arguments.
  const queryStringIndex = url.indexOf('?');
  if (queryStringIndex !== -1) {
    // Merge into existing query arguments.
    args = Object.assign(getQueryArgs(url), args);

    // Change working base URL to omit previous query arguments.
    baseUrl = baseUrl.substr(0, queryStringIndex);
  }
  return baseUrl + '?' + buildQueryString(args) + fragment;
}

;// ./node_modules/@wordpress/url/build-module/get-query-arg.js
/**
 * Internal dependencies
 */


/**
 * @typedef {{[key: string]: QueryArgParsed}} QueryArgObject
 */

/**
 * @typedef {string|string[]|QueryArgObject} QueryArgParsed
 */

/**
 * Returns a single query argument of the url
 *
 * @param {string} url URL.
 * @param {string} arg Query arg name.
 *
 * @example
 * ```js
 * const foo = getQueryArg( 'https://wordpress.org?foo=bar&bar=baz', 'foo' ); // bar
 * ```
 *
 * @return {QueryArgParsed|void} Query arg value.
 */
function getQueryArg(url, arg) {
  return getQueryArgs(url)[arg];
}

;// ./node_modules/@wordpress/url/build-module/has-query-arg.js
/**
 * Internal dependencies
 */


/**
 * Determines whether the URL contains a given query arg.
 *
 * @param {string} url URL.
 * @param {string} arg Query arg name.
 *
 * @example
 * ```js
 * const hasBar = hasQueryArg( 'https://wordpress.org?foo=bar&bar=baz', 'bar' ); // true
 * ```
 *
 * @return {boolean} Whether or not the URL contains the query arg.
 */
function hasQueryArg(url, arg) {
  return getQueryArg(url, arg) !== undefined;
}

;// ./node_modules/@wordpress/url/build-module/remove-query-args.js
/**
 * Internal dependencies
 */



/**
 * Removes arguments from the query string of the url
 *
 * @param {string}    url  URL.
 * @param {...string} args Query Args.
 *
 * @example
 * ```js
 * const newUrl = removeQueryArgs( 'https://wordpress.org?foo=bar&bar=baz&baz=foobar', 'foo', 'bar' ); // https://wordpress.org?baz=foobar
 * ```
 *
 * @return {string} Updated URL.
 */
function removeQueryArgs(url, ...args) {
  const fragment = url.replace(/^[^#]*/, '');
  url = url.replace(/#.*/, '');
  const queryStringIndex = url.indexOf('?');
  if (queryStringIndex === -1) {
    return url + fragment;
  }
  const query = getQueryArgs(url);
  const baseURL = url.substr(0, queryStringIndex);
  args.forEach(arg => delete query[arg]);
  const queryString = buildQueryString(query);
  const updatedUrl = queryString ? baseURL + '?' + queryString : baseURL;
  return updatedUrl + fragment;
}

;// ./node_modules/@wordpress/url/build-module/prepend-http.js
/**
 * Internal dependencies
 */

const USABLE_HREF_REGEXP = /^(?:[a-z]+:|#|\?|\.|\/)/i;

/**
 * Prepends "http://" to a url, if it looks like something that is meant to be a TLD.
 *
 * @param {string} url The URL to test.
 *
 * @example
 * ```js
 * const actualURL = prependHTTP( 'wordpress.org' ); // http://wordpress.org
 * ```
 *
 * @return {string} The updated URL.
 */
function prependHTTP(url) {
  if (!url) {
    return url;
  }
  url = url.trim();
  if (!USABLE_HREF_REGEXP.test(url) && !isEmail(url)) {
    return 'http://' + url;
  }
  return url;
}

;// ./node_modules/@wordpress/url/build-module/safe-decode-uri.js
/**
 * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if
 * `decodeURI` throws an error.
 *
 * @param {string} uri URI to decode.
 *
 * @example
 * ```js
 * const badUri = safeDecodeURI( '%z' ); // does not throw an Error, simply returns '%z'
 * ```
 *
 * @return {string} Decoded URI if possible.
 */
function safeDecodeURI(uri) {
  try {
    return decodeURI(uri);
  } catch (uriError) {
    return uri;
  }
}

;// ./node_modules/@wordpress/url/build-module/filter-url-for-display.js
/**
 * Returns a URL for display.
 *
 * @param {string}      url       Original URL.
 * @param {number|null} maxLength URL length.
 *
 * @example
 * ```js
 * const displayUrl = filterURLForDisplay( 'https://www.wordpress.org/gutenberg/' ); // wordpress.org/gutenberg
 * const imageUrl = filterURLForDisplay( 'https://www.wordpress.org/wp-content/uploads/img.png', 20 ); // вЂ¦ent/uploads/img.png
 * ```
 *
 * @return {string} Displayed URL.
 */
function filterURLForDisplay(url, maxLength = null) {
  if (!url) {
    return '';
  }

  // Remove protocol and www prefixes.
  let filteredURL = url.replace(/^[a-z\-.\+]+[0-9]*:(\/\/)?/i, '').replace(/^www\./i, '');

  // Ends with / and only has that single slash, strip it.
  if (filteredURL.match(/^[^\/]+\/$/)) {
    filteredURL = filteredURL.replace('/', '');
  }

  // capture file name from URL
  const fileRegexp = /\/([^\/?]+)\.(?:[\w]+)(?=\?|$)/;
  if (!maxLength || filteredURL.length <= maxLength || !filteredURL.match(fileRegexp)) {
    return filteredURL;
  }

  // If the file is not greater than max length, return last portion of URL.
  filteredURL = filteredURL.split('?')[0];
  const urlPieces = filteredURL.split('/');
  const file = urlPieces[urlPieces.length - 1];
  if (file.length <= maxLength) {
    return 'вЂ¦' + filteredURL.slice(-maxLength);
  }

  // If the file is greater than max length, truncate the file.
  const index = file.lastIndexOf('.');
  const [fileName, extension] = [file.slice(0, index), file.slice(index + 1)];
  const truncatedFile = fileName.slice(-3) + '.' + extension;
  return file.slice(0, maxLength - truncatedFile.length - 1) + 'вЂ¦' + truncatedFile;
}

// EXTERNAL MODULE: ./node_modules/remove-accents/index.js
var remove_accents = __webpack_require__(9681);
var remove_accents_default = /*#__PURE__*/__webpack_require__.n(remove_accents);
;// ./node_modules/@wordpress/url/build-module/clean-for-slug.js
/**
 * External dependencies
 */


/**
 * Performs some basic cleanup of a string for use as a post slug.
 *
 * This replicates some of what `sanitize_title_with_dashes()` does in WordPress core, but
 * is only designed to approximate what the slug will be.
 *
 * Converts Latin-1 Supplement and Latin Extended-A letters to basic Latin
 * letters. Removes combining diacritical marks. Converts whitespace, periods,
 * and forward slashes to hyphens. Removes any remaining non-word characters
 * except hyphens. Converts remaining string to lowercase. It does not account
 * for octets, HTML entities, or other encoded characters.
 *
 * @param {string} string Title or slug to be processed.
 *
 * @return {string} Processed string.
 */
function cleanForSlug(string) {
  if (!string) {
    return '';
  }
  return remove_accents_default()(string)
  // Convert &nbsp, &ndash, and &mdash to hyphens.
  .replace(/(&nbsp;|&ndash;|&mdash;)/g, '-')
  // Convert each group of whitespace, periods, and forward slashes to a hyphen.
  .replace(/[\s\./]+/g, '-')
  // Remove all HTML entities.
  .replace(/&\S+?;/g, '')
  // Remove anything that's not a letter, number, underscore or hyphen.
  .replace(/[^\p{L}\p{N}_-]+/gu, '')
  // Convert to lowercase
  .toLowerCase()
  // Replace multiple hyphens with a single one.
  .replace(/-+/g, '-')
  // Remove any remaining leading or trailing hyphens.
  .replace(/(^-+)|(-+$)/g, '');
}

;// ./node_modules/@wordpress/url/build-module/get-filename.js
/* wp:polyfill */
/**
 * Returns the filename part of the URL.
 *
 * @param {string} url The full URL.
 *
 * @example
 * ```js
 * const filename1 = getFilename( 'http://localhost:8080/this/is/a/test.jpg' ); // 'test.jpg'
 * const filename2 = getFilename( '/this/is/a/test.png' ); // 'test.png'
 * ```
 *
 * @return {string|void} The filename part of the URL.
 */
function getFilename(url) {
  let filename;
  if (!url) {
    return;
  }
  try {
    filename = new URL(url, 'http://example.com').pathname.split('/').pop();
  } catch (error) {}
  if (filename) {
    return filename;
  }
}

;// ./node_modules/@wordpress/url/build-module/normalize-path.js
/**
 * Given a path, returns a normalized path where equal query parameter values
 * will be treated as identical, regardless of order they appear in the original
 * text.
 *
 * @param {string} path Original path.
 *
 * @return {string} Normalized path.
 */
function normalizePath(path) {
  const split = path.split('?');
  const query = split[1];
  const base = split[0];
  if (!query) {
    return base;
  }

  // 'b=1%2C2&c=2&a=5'
  return base + '?' + query
  // [ 'b=1%2C2', 'c=2', 'a=5' ]
  .split('&')
  // [ [ 'b, '1%2C2' ], [ 'c', '2' ], [ 'a', '5' ] ]
  .map(entry => entry.split('='))
  // [ [ 'b', '1,2' ], [ 'c', '2' ], [ 'a', '5' ] ]
  .map(pair => pair.map(decodeURIComponent))
  // [ [ 'a', '5' ], [ 'b, '1,2' ], [ 'c', '2' ] ]
  .sort((a, b) => a[0].localeCompare(b[0]))
  // [ [ 'a', '5' ], [ 'b, '1%2C2' ], [ 'c', '2' ] ]
  .map(pair => pair.map(encodeURIComponent))
  // [ 'a=5', 'b=1%2C2', 'c=2' ]
  .map(pair => pair.join('='))
  // 'a=5&b=1%2C2&c=2'
  .join('&');
}

;// ./node_modules/@wordpress/url/build-module/prepend-https.js
/**
 * Internal dependencies
 */


/**
 * Prepends "https://" to a url, if it looks like something that is meant to be a TLD.
 *
 * Note: this will not replace "http://" with "https://".
 *
 * @param {string} url The URL to test.
 *
 * @example
 * ```js
 * const actualURL = prependHTTPS( 'wordpress.org' ); // https://wordpress.org
 * ```
 *
 * @return {string} The updated URL.
 */
function prependHTTPS(url) {
  if (!url) {
    return url;
  }

  // If url starts with http://, return it as is.
  if (url.startsWith('http://')) {
    return url;
  }
  url = prependHTTP(url);
  return url.replace(/^http:/, 'https:');
}

;// ./node_modules/@wordpress/url/build-module/index.js





























})();

(window.wp = window.wp || {}).url = __webpack_exports__;
/******/ })()
;
